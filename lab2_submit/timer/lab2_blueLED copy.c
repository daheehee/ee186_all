/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

volatile uint32_t* port_clk = (uint32_t*) 0x4002104C;
volatile uint32_t* syscfg_port_clk = (uint32_t*) 0x40021060;
volatile uint32_t* sysclk = (uint32_t*) 0x40021000;//9th bit (8)
volatile uint32_t* sysclk_config = (uint32_t*) 0x40021008;//9th bit (8)
volatile uint32_t* tim4_port_clk = (uint32_t*) 0x40021058; //3rd bit (2)

volatile uint32_t* tim4_en = (uint32_t*) 0x40000800;
volatile uint32_t* tim4_interrupt_en = (uint32_t*) 0x4000080C;
volatile uint32_t* tim4_psc = (uint32_t*) 0x40000828;
volatile uint32_t* tim4_egr = (uint32_t*) 0x40000814;
volatile uint32_t* tim4_arr = (uint32_t*) 0x4000082C;

volatile uint32_t* tim4_sr = (uint32_t*) 0x40000810;

//push button is port C, LED is port B
volatile uint32_t* gpioC_mode = (uint32_t*) 0x48000800;
volatile uint32_t* gpioB_mode = (uint32_t*) 0x48000400;
volatile uint32_t* gpioC_type = (uint32_t*) 0x48000804;
volatile uint32_t* gpioB_type = (uint32_t*) 0x48000404;
volatile uint32_t* gpioC_speed = (uint32_t*) 0x48000808;
volatile uint32_t* gpioB_speed = (uint32_t*) 0x48000408;
volatile uint32_t* gpioC_pull = (uint32_t*) 0x4800080C;
volatile uint32_t* gpioB_pull = (uint32_t*) 0x4800040C;
volatile uint32_t* gpioC_set = (uint32_t*) 0x48000818;
volatile uint32_t* gpioB_set = (uint32_t*) 0x48000418;
volatile uint32_t* gpioC_out = (uint32_t*) 0x48000814;
volatile uint32_t* gpioB_out = (uint32_t*) 0x48000414;

volatile uint32_t* SYSCFG = (uint32_t*) 0x40010014;
volatile uint32_t* NVIC_ISER1 = (uint32_t*) 0xE000E104;
volatile uint32_t* NVIC_ISER0 = (uint32_t*) 0xE000E100;
volatile uint32_t* EXTI_IMR1 = (uint32_t*) 0x40010400;
volatile uint32_t* EXTI_RTSR1 = (uint32_t*) 0x40010408;
volatile uint32_t* EXTI_FTSR1 = (uint32_t*) 0x4001040C;
volatile uint32_t* EXTI_PR1 = (uint32_t*) 0x40010414;

uint32_t LED_mask = 1 << 7;
uint32_t button_mask = 1 << 13;


int main(void)
{
	//set clock and gpio
	*port_clk &= ~(0b11 << 1);
	*port_clk |= 0b11 << 1; //restarting port b and c
	*sysclk_config |= 0x01;
	*syscfg_port_clk |= (1u << 0);
	*sysclk |= (1 << 8);

	while (((*sysclk_config >> 2) & 0b11) != 0b01){

	}
	*sysclk_config &= ~(0b1111 << 4);
	*tim4_port_clk |= (1u << 2);

	*tim4_en |= (1u << 0);
	*tim4_interrupt_en |= (1u << 0);
	*tim4_psc |= (244u);
	*tim4_egr |= (1u << 0);
	*tim4_arr |= (0xFFFF);


	*gpioC_mode &= ~(0b11 << 26);
	*gpioB_mode &= ~(0b11 << 14);
	*gpioB_mode |= (0b01 << 14);

//	*gpioC_type &= ~(0b01 << 13);
	*gpioB_type &= ~(0b01 << 7);

	*gpioC_speed &= ~(0b11 << 26);
	*gpioB_speed |= (0b11 << 26);
	*gpioC_speed &= ~(0b11 << 14);
	*gpioB_speed |= (0b11 << 14);

	*gpioC_pull &= ~(0b11 << 26);
	*gpioB_pull &= ~(0b11 << 14);

	*gpioB_set &= ~(0b01 << 7);
	*gpioB_set |= (0b01 << 7);
	*gpioC_set &= ~(0b01 << 13);
	*gpioC_set |= (0b01 << 13);

	*gpioB_out &= ~(0b01 << 7);

	*NVIC_ISER1 |= (0b01 << 8);
	*NVIC_ISER0 |= (0b01 << 30);

	//NVIC and what not
	//configure SYSCFG_EXTI13 for GPIOC13
	*SYSCFG &= ~(0xF << 4);
	*SYSCFG |= 0x2 << 4;

	//confgiure rising trigger, interup mask reg, and pending request reg
	*EXTI_IMR1 |= (0x1 << 13);

	*EXTI_FTSR1 |= (0x1 << 13);
	*EXTI_RTSR1 &= ~(0x1  << 13);

//	*EXTI_PR1 |= (1 << 13);


	//enable NVIC ISER (position 40)

	while(1)
	{

	}
}
void TIM4_IRQHandler(void){
//	if ((*EXTI_PR1) & (1u << 13)){
	*gpioB_out ^= 1 << 7;
	*tim4_sr &= ~(1 << 0);
//	*EXTI_PR1 = (1u << 13);
}

void EXTI15_10_IRQHandler(void){
	//invert the right led bit
	//xor
	if ((*EXTI_PR1) & (1u << 13)){
	*gpioB_out ^= 1 << 7;
	*EXTI_PR1 = (1u << 13);
	}
}
